1
00:00:00,000 --> 00:00:09,000
大家好,欢迎来到讨论二,我们今天将介绍Java的基础知识。

2
00:00:09,000 --> 00:00:24,000
需要说明的是,没有讨论一,你们没有错过任何内容,
这就是第二周的讨论,我们就是这样安排的。好了,
今天希望你们已经通过实验和项目零获得了一些Java的编程经验。 

3
00:00:24,000 --> 00:00:31,000
我们将进一步巩固一些更重要的细节,增加你们对Java的熟悉度和信心。

4
00:00:31,000 --> 00:00:35,000
本周的课程安排是:实验一要在星期二提交。

5
00:00:35,000 --> 00:00:48,000
我认为这个视频会在星期三发布,所以实验一的截止日期已经过了。
项目零要在本星期五提交。实验二也要在本星期五提交。办公时间也会在这周开始。
在发帖前,请阅读我们的新规定,因为我们修改了一些规则。所有这些通知

6
00:00:48,000 --> 00:00:56,000
以及更多详情都在edu平台的每周公告帖子中详细说明,
希望你们都已经阅读了公告,因为这是必须的。

7
00:00:56,000 --> 00:01:07,000
这就是本周的所有通知。这些幻灯片以及其他资料都可以在网站上找到,
你们可能已经知道了,因为你们正在观看这个视频。

8
00:01:07,000 --> 00:01:11,000
我们现在将直接进入练习。

9
00:01:11,000 --> 00:01:26,000  

首先是问题一,我们的第一个Java程序。

请在每行代码旁边写下你认为这行代码将做什么以及它的运行结果。
如果你认为某行代码会出错,请修改错误,然后继续执行你修改后的代码。

10
00:01:26,000 --> 00:01:36,000

我会给你一点时间暂停视频,自己思考并尝试解决这个问题,然后我们再继续。

11
00:01:36,000 --> 00:01:45,000

好的,我假设你已经暂停并回来,因为你已经尝试过这个问题了。
我们将逐行查看代码,就像Java实际执行的方式一样。

12
00:01:45,000 --> 00:01:49,000

首先我们看到 size = 27。

13
00:01:49,000 --> 00:02:07,000

我认为这行会报错,因为在Java中,我们需要声明变量的类型。
当我们写 size = 27 时,Java需要知道size是什么类型的变量。

14
00:02:07,000 --> 00:02:23,000  

因为它被赋值为27,我们可以假设 int size = 27将是修正这行代码的充分方式。
在Java中还有其他数字类型,如double、float等。

15  
00:02:23,000 --> 00:02:27,000

但现在我们用int类型,因为你们可能最熟悉它。

16
00:02:27,000 --> 00:02:35,000

我们有 name = Fido。那么换句话说,第2行代码是否正确?

17
00:02:35,000 --> 00:02:42,000

我认为它还是会报错。应该是这样的:

18
00:02:42,000 --> 00:02:46,000

String name = Fido。

19
00:02:46,000 --> 00:02:48,000

很好,做了一些修改。

20
00:02:48,000 --> 00:02:59,000

现在我们看到 dog myDog = new Dog(name, size)。
假设name和size现在都是有效的变量,我们可以使用它们。

21
00:02:59,000 --> 00:03:09,000

我认为这行代码看起来正确。假设有一个Dog类,它的构造函数接受名为name和size的变量,
这些变量大概是一个字符串和一个数字。

22
00:03:09,000 --> 00:03:27,000

这行代码应该可以工作。那么我们将拥有一个小狗,名为myDog。他的名字是Fido,大小是27。

23
00:03:27,000 --> 00:03:35,000

我们实际上不知道这些变量在底层的名称。我假设它们指的是某种名字和大小。

24
00:03:35,000 --> 00:03:46,000

然后我们有 yourDog。这是另一个新的Dog实例。这次我们没有像name和size那样传入变量,
而是直接传入了一个字符串和一个数字。

25
00:03:46,000 --> 00:03:51,000 

但这行代码仍然有效,对吧。所以现在我们有另一个对象。

26
00:03:51,000 --> 00:04:02,000

它由变量yourDog引用。我们再次有scruffy和1000,这是一只大狗。

27
00:04:03,000 --> 00:04:12,000

然后我们用这个语法创建一个Dog列表:Dog[] dogList = new Dog[3]。

28
00:04:12,000 --> 00:04:29,000

这行代码声明了一个大小为3的数组,并对其进行了初始化。这意味着我们有一个空数组,
我们还没有把任何东西放进去。

29
00:04:30,000 --> 00:04:32,000

谁知道最终会放什么东西在里面。

30
00:04:32,000 --> 00:04:50,000

但这行代码就是做这个的。然后下一行,我们把某些东西放进数组里。我们说dogList[0] 是 myDog。请记住Java是从0开始索引的,这意味着这些小角标数字就是索引值。

31
00:04:50,000 --> 00:05:01,000

所以dogList[0]将指向那个0号元素,也就是对人类来说的第一个位置。
然后我们说dogList[1] 等于 yourDog。

32
00:05:01,000 --> 00:05:04,000

到目前为止都好。  

33
00:05:04,000 --> 00:05:06,000

现在,我们能说dogList[2] = 5吗?

34
00:05:06,000 --> 00:05:11,000

我认为这行不会起作用,因为在Java中,数组和其他所有容器类型的数据

35
00:05:11,000 --> 00:05:18,000

当我说其他所有,我的意思是像数组这样的容器类型,只能容纳一种类型的变量、对象等。

36
00:05:18,000 --> 00:05:28,000

如果我们说dogList是一个Dog数组,它只能容纳Dog,而数字5不是Dog,所以不能放进去。

37
00:05:28,000 --> 00:05:52,000

为了修正这行代码,我们可以把它设置为一个有效的Dog实例,比如我不知道,
一个名字是Socks,体重是25磅的Dog。这样我们也可以删除这行代码。
无论哪种方式,我们都要消除错误。

38
00:05:53,000 --> 00:06:00,000

接下来,好吧,我们假设这里现在指向我非常帅的狗Socks。他是一只小白毛汪。

39
00:06:00,000 --> 00:06:11,000

好的。

40
00:06:11,000 --> 00:06:13,000

然后我们有这一行代码。

41
00:06:13,000 --> 00:06:18,000

dogList[3] = new Dog("Cutie", 8) 这行代码能工作吗?

42
00:06:18,000 --> 00:06:24,000

请花点时间思考一下,这行代码能运行吗。

43
00:06:24,000 --> 00:06:27,000

我说不行,因为数组没有索引3这个位置。

44
00:06:27,000 --> 00:06:35,000

这行代码会产生一个索引越界的错误。一种修正方法是简单地将其更改为一个有效的索引。

45
00:06:35,000 --> 00:06:48,000

这样我们会覆盖之前的Socks对象。对不起,Socks。现在它会指向Cutie。

46
00:06:48,000 --> 00:06:50,000

对不起,Socks。

47  
00:06:50,000 --> 00:06:53,000

它现在会指向Cutie。

48
00:06:53,000 --> 00:07:08,000

另一种可能的方法是在一开始就将这个数组的大小设为4,
这样这行代码在后面就不会报错了。需要注意的是,在Java中你不能扩展或者增大数组的大小。

49
00:07:08,000 --> 00:07:22,000

如果你声明它的大小为3,它的大小就永远是3,不像Python可以用append方法来增大大小,
数组大小一旦设定就无法更改。如果要拓展到一个更大的数组,
你需要将整个数组复制到一个新的更大的数组中。

50
00:07:22,000 --> 00:07:24,000

就是这样。

51
00:07:24,000 --> 00:07:26,000

好的。

52
00:07:26,000 --> 00:07:40,000

然后下一行我们声明一个整数x。所以在这里我们只是声明x,没有初始化,
在Java中这样也可以,你可以先声明后初始化。

53
00:07:40,000 --> 00:07:50,000

然后在这里我们对它进行了初始化并给x一个值。我们说它是size减5。
假设我们之前的size这一行代码被修正了。

54
00:07:50,000 --> 00:07:57,000

如果size是27,size减5是22,所以x实际上是22。

55
00:07:57,000 --> 00:08:06,000

现在我们说,如果x小于15,我们将调用dogBark,但x并不小于15,所以我们跳过这个代码块。

56
00:08:06,000 --> 00:08:07,000

很好。

57
00:08:07,000 --> 00:08:10,000

我们现在进入问题2,神秘函数。

58
00:08:10,000 --> 00:08:18,000

这是一个方法,在Java中也叫函数,它接收一个整数数组和一个整数作为参数。

59
00:08:18,000 --> 00:08:26,000

它返回一个整数,所以从这个方法签名中我们可以看到它接收一个整数数组和一个整数,
并返回一个整数。

60
00:08:26,000 --> 00:08:38,000

现在,这是这个方法的实现,我们的第一个问题是,
如果输入数组为[3,0,4,6,3],k等于2,mystery会返回什么。

61
00:08:38,000 --> 00:08:43,000

让我们再次暂停视频,你可以自行尝试解决这个问题。

62
00:08:43,000 --> 00:08:47,000

然后我们一起过一遍。

63
00:08:47,000 --> 00:08:52,000

我假设你已经暂停,回来了,我想你了,我们分开的时间太久了。

64
00:08:53,000 --> 00:09:04,000

那么,我们暂时假装自己是Java,输入数组为[3,0,4,6,3],k为2。

65
00:09:04,000 --> 00:09:08,000

我们一行一行地执行代码,因为Java就是这样工作的。

66
00:09:08,000 --> 00:09:12,000

首先我们说,int x = inputArray[k]。

67
00:09:12,000 --> 00:09:19,000

所以,我们取k的值,这里是2,然后取数组中索引为k的元素。

68
00:09:19,000 --> 00:09:29,000

记住Java是从0开始索引的,所以这个数组是012345,
这意味着数组中索引k对应的元素是4。

69
00:09:29,000 --> 00:09:33,000

所以现在我们有 x = 4。

70
00:09:33,000 --> 00:09:36,000

然后我们说 int answer = k。

71
00:09:36,000 --> 00:09:42,000

现在,answer是2,因为k等于2。

72
00:09:42,000 --> 00:09:46,000

然后我们说 int index = k + 1。

73
00:09:46,000 --> 00:09:50,000

所以,index等于3。

74
00:09:50,000 --> 00:09:55,000

现在我们说,index小于inputArray.length。

75
00:09:55,000 --> 00:10:04,000

这里我们得到一个提示,接下来我们可能会遍历数组,这个检查可以确保我们不会越界。

76
00:10:04,000 --> 00:10:10,000

如果索引小于数组长度,我们永远不会超过数组的边界。

77
00:10:10,000 --> 00:10:19,000

然后我们说,如果inputArray[index]小于x,那么首先我们来看看这里对应的值是什么。

78
00:10:19,000 --> 00:10:23,000

所以我们的输入数组是这样的。

79
00:10:23,000 --> 00:10:36,000

index是3,所以inputArray[index],也就是3对应的元素是6。

80
00:10:36,000 --> 00:10:40,000

如果它小于x,而x是4。

81
00:10:40,000 --> 00:10:47,000

暂时不考虑if语句,因为我们还没进入if语句。

82
00:10:47,000 --> 00:10:53,000

6大于4。所以我们跳过if语句,index加1。

83
00:10:53,000 --> 00:10:59,000

现在,index等于4。

84
00:10:59,000 --> 00:11:03,000

然后我们再次回到while循环的顶部。

85
00:11:03,000 --> 00:11:06,000

如果index仍然小于数组长度,条件为真。

86
00:11:06,000 --> 00:11:10,000

4小于数组长度5,条件满足。

87
00:11:10,000 --> 00:11:24,000

如果inputArray[index],数组中索引4对应的元素是3。所以这里整个语句对应的值是3。

88
00:11:24,000 --> 00:11:28,000

如果它小于x,x是4。

89
00:11:28,000 --> 00:11:40,000
这是正确的,3小于4,inputArray[index],也就是索引4对应的元素小于x。

90
00:11:40,000 --> 00:11:42,000  
把这些都写下来肯定会有帮助。

91
00:11:42,000 --> 00:11:49,000
然后我们进入if语句,说x现在等于那个值。

92
00:11:49,000 --> 00:11:54,000

所以,x会等于3。

93
00:11:54,000 --> 00:12:04,000

然后我们说,answer等于index。所以此时,answer变为4,因为index是4。

94
00:12:04,000 --> 00:12:12,000

然后我们再次递增index,出了if语句之后,index变成5。

95
00:12:12,000 --> 00:12:16,000

5是否还小于inputArray.length呢?

96
00:12:17,000 --> 00:12:28,000

我们退出while循环,并返回answer。我们最终返回的是。

97
00:12:28,000 --> 00:12:34,000

所以,它返回的是这个。

98
00:12:34,000 --> 00:12:45,000

你能用简单的英文解释一下mystery函数到底在做什么吗?让我们看看我们刚才所做的步骤,
并试着一起弄清楚。我们传入了一个输入数组和一个数K。

99
00:12:45,000 --> 00:12:50,000

我们查看了索引为K的元素,并将其记录为x。

100
00:12:50,000 --> 00:12:58,000

然后我们从K开始迭代数组,检查当前元素是否小于x。

101
00:12:58,000 --> 00:13:08,000

如果它比x小,我们就将答案更改为该较小元素的索引,我们遍历整个数组做这件事,
从K及其之后的位置找到最小的元素。

102
00:13:08,000 --> 00:13:22,000

我认为这个函数的全部作用就是,你传入一个数组,查看K之后的最小元素索引。

103
00:13:22,000 --> 00:13:28,000

在这里,我们可以看到传入的是2。

104
00:13:29,000 --> 00:13:33,000

我再把它写一遍,这样我们可以在上面涂涂画画。

105
00:13:33,000 --> 00:13:46,000

我们传入索引2,从2及之后最小的元素是3,最小元素的索引是4,这就是为什么返回4。

106
00:13:46,000 --> 00:13:53,000

我们没有返回最小元素本身3,而是返回我们发现它的位置。

107
00:13:53,000 --> 00:14:04,000

如果你并没有完全理解这个函数的作用,我们举另一个例子:

108
00:14:04,000 --> 00:14:14,000

比如传入数组[5, 1, 2, 3, 7, 8],

109
00:14:14,000 --> 00:14:25,000

索引给它1,它会查看元素0,1,2,3,4,5,基本上就是这个子数组,
找到最小的元素,在这种情况下是1,并返回最小元素的索引,也就是1。

110
00:14:25,000 --> 00:14:38,000

比如,如果传入同样的数组,但索引是4,它只会查看索引4及之后的元素,
找到最小的元素,并返回最小元素的索引,在这种情况下是4。这就是mystery的工作方式。

111
00:14:38,000 --> 00:14:49,000

这个函数有点奇怪,我不知道在什么情况下会用到它,
但希望通过这个练习你可以掌握如何查看Java代码并理解它的作用。

112
00:14:49,000 --> 00:14:57,000

这在你作为程序员的实际工作中非常重要,当你能够查看一个庞大的代码库
并通过阅读理解其工作原理时,它真的非常有用。

113
00:14:57,000 --> 00:15:07,000

好的,现在我们有一个额外的问题。再次给你一点时间阅读问题描述,并描述一下,
如果输入数组是[3,0,4,6,3],mystery2会做什么。

114
00:15:07,000 --> 00:15:22,000

让我们暂停一会儿这个美好的视频,然后再回来。

115
00:15:22,000 --> 00:15:31,000

我假定你已经暂停了一段时间。留出这么长的间隔是因为我真的希望你暂停并完成。

116
00:15:31,000 --> 00:15:38,000

那么,让我们再次逐行查看这个代码。

117
00:15:38,000 --> 00:15:42,000

同样,你传入一个输入数组。

118
00:15:42,000 --> 00:15:52,000  

假设它是[3,0,4,6,3],不知道为什么我的笔变成了黑色。

119
00:15:52,000 --> 00:15:57,000

我们说 int index = 0。

120
00:15:58,000 --> 00:16:11,000

当index小于长度时,这个条件为真,
我们说int targetIndex = mystery(inputArray, index)。
再次回想一下我们刚才说mystery的作用。

121
00:16:11,000 --> 00:16:22,000

我们知道如果用这个数组和索引0调用mystery,它会从索引0处及其之后查看整个数组。

122
00:16:22,000 --> 00:16:32,000

在这里,就是整个数组,它会找到最小元素的索引。在这里,
索引1是最小元素,因为索引0对应的元素是最小的。

123
00:16:32,000 --> 00:16:49,000

所以,targetIndex等于,天啊我拼错了,index等于1,
因为mystery以这个输入数组和索引0被调用时会返回1。

124
00:16:49,000 --> 00:17:04,000

然后我们说 int temp = inputArray[targetIndex]。
所以目前,temp就是inputArray[1],也就是0。

125
00:17:04,000 --> 00:17:14,000

然后我们说inputArray[targetIndex] = inputArray[index]。实际上,

126
00:17:14,000 --> 00:17:27,000

我们正在改变数组,我们说在索引1处设置为inputArray[index],
也就是索引0处的值。所以索引0的值是3。

127
00:17:27,000 --> 00:17:29,000

然后我们索引加1。

128
00:17:29,000 --> 00:17:32,000

我就直接做了。

129
00:17:32,000 --> 00:17:36,000

现在回到while循环的顶部。

130
00:17:36,000 --> 00:17:39,000

索引仍然小于输入数组的长度5。

131
00:17:39,000 --> 00:17:43,000

我们说目标索引再次调用mystery,但是这次索引是1。

132
00:17:43,000 --> 00:17:49,000

同样,mystery会查看索引1及之后的元素。

133
00:17:49,000 --> 00:17:57,000

所以我们看这个数组,我们会找到最小的元素。我认为取第一个3就可以了,
我不认为并列的情况真的重要。

134
00:17:57,000 --> 00:18:11,000

其实,如果你回头看mystery函数,你会注意到,
由于函数的工作方式,只有严格小于时才会交换它们。

135
00:18:11,000 --> 00:18:22,000

换句话说,只有第二个3严格小于第一个3时,它才会将第二个3标记为最小元素,
但事实并非如此。 所以我们知道答案是1。

136 
00:18:22,000 --> 00:18:25,000

但我发现了。

137
00:18:25,000 --> 00:18:27,000

继续。

138
00:18:27,000 --> 00:18:29,000

输入数组。

139
00:18:29,000 --> 00:18:38,000

所以我们调用mystery。到目前为止对这个数组,我们再说一次,
第一个3是最小的,我不认为并列很重要。

140
00:18:38,000 --> 00:18:49,000  

实际上,如果你返回mystery,你会注意到它的工作方式。
只有严格小于时才会交换它们。

141
00:18:49,000 --> 00:19:03,000

换句话说,它只会在严格小于第一个3时才将第二个3标记为最小元素,
但事实并非如此。所以我们知道答案是1。

142
00:19:03,000 --> 00:19:08,000

所以targetIndex仍然是1。

143
00:19:08,000 --> 00:19:15,000

temp是inputArray[targetIndex],也就是3。

144
00:19:16,000 --> 00:19:28,000

然后我们基本上说inputArray[targetIndex]等于inputArray[index]。
实际上这行什么也没做,因为我们说inputArray[1]等于inputArray[1],没有变化。

145
00:19:28,000 --> 00:19:36,000

然后我们再说inputArray[1]等于temp,它本来就是那个值。没关系。

146
00:19:36,000 --> 00:19:43,000

然后我们说index += 1。现在它是2。我们再次回到while循环顶部。

147
00:19:43,000 --> 00:19:57,000

所以,我们仍然满足条件。我们说targetIndex等于mystery(inputArray, 2)。
这意味着我们正在查看索引2及之后的子数组元素。

148
00:19:57,000 --> 00:20:04,000

所以我们知道mystery会找到最小元素,这里是3,并且会

149
00:20:04,000 --> 00:20:14,000

返回该最小元素的索引,所以是4,因为4小于6,4的索引是4。
这就是targetIndex被设置的值。所以targetIndex仍然是4。

150
00:20:14,000 --> 00:20:33,000

然后我们说temp等于inputArray[targetIndex]。所以inputArray[4]等于3。
然后我们说inputArray[targetIndex]等于inputArray[index]。

151
00:20:33,000 --> 00:20:44,000

然后我们说inputArray[4]等于inputArray[2]。所以4移到这里。

152
00:20:44,000 --> 00:20:50,000

然后我们说inputArray[index]等于temp。

153
00:20:50,000 --> 00:20:52,000

所以,这变成3。

154
00:20:52,000 --> 00:21:06,000

我们可以看到一个模式,我们正在遍历数组,每次使用mystery找到迄今为止的最小元素,
因为mystery会找到最小元素的索引。

155
00:21:06,000 --> 00:21:14,000

然后我们用当前元素交换最小元素,并对每个索引执行此操作,
直到我们最终找到最小元素并将其放在正确的位置。

156
00:21:14,000 --> 00:21:27,000  

知道这一点,当我们来这里时,我们可能会交换6和4。
让我们继续看看是否能证实这一点。
所以索引增加到3,我们回到while循环顶部。

157
00:21:27,000 --> 00:21:39,000

3仍然小于5。我们说targetIndex等于mystery(inputArray, 3)。
这意味着我们正在查看索引3及之后的元素。

158  
00:21:39,000 --> 00:21:57,000

所以4我们知道mystery会找到最小元素的索引。所以是4因为4小于6,4的索引是4。
这就是targetIndex被设置的值。所以targetIndex还是4。

159
00:21:57,000 --> 00:22:09,000

然后我们说temp等于inputArray[targetIndex]。所以inputArray[4]等于4。

160
00:22:09,000 --> 00:22:15,000  

然后我们说inputArray[index],索引是3,等于temp。

161
00:22:16,000 --> 00:22:35,000

inputArray[targetIndex]等于inputArray[index]。跳过这行代码。
所以inputArray[4]等于inputArray[3],也就是6。然后我们执行这一行,
将inputArray[index] 3设置为temp,也就是4。

162
00:22:36,000 --> 00:22:47,000

我们可以看到一个模式,我们正在遍历数组,每次找到迄今为止的最小元素,
将其与当前元素交换,并将当前元素放到最小元素所在的位置。

163
00:22:47,000 --> 00:23:03,000

一直重复这个过程,直到我们最终找到最小的元素并将其放在正确的位置。
这实际上是一个叫选择排序的算法。如果你想了解更多,我们将在后面的课程中介绍它,
或者你现在就可以去搜索相关的视频和教程。

164
00:23:03,000 --> 00:23:19,000

选择排序是一个非常常见且重要的算法,
有大量很酷的视频和资料可以教你为什么选择排序如此重要。

165
00:23:19,000 --> 00:23:25,000

最后,我们来讨论第三个问题,编写你的第一个程序。

166
00:23:25,000 --> 00:23:32,000 

这个问题会让你获得一些实际的编程经验,开始编写一个小算法。

167
00:23:32,000 --> 00:23:41,000

我们要求你实现fib函数,它接受一个整数n并返回第n个斐波那契数,
你可能不需要使用所有的代码行。

168
00:23:41,000 --> 00:23:50,000

如果你不知道斐波那契数列是什么,它基本上是把前两个数字相加得到当前数字。

169
00:23:50,000 --> 00:23:57,000

让我具体向你展示什么意思。这个数列中的前两个数字是0和1。

170
00:23:57,000 --> 00:24:03,000

后面的数字将是前两个数字相加。所以0加1等于1。

171
00:24:03,000 --> 00:24:09,000 

那么下一个数字是多少呢?前两个数字是1和1,所以1加1等于2。

172
00:24:09,000 --> 00:24:19,000

2加1等于3。下一个数字是什么呢?3加2等于5。5加3等于8。8加5等于13,以此类推。

173
00:24:19,000 --> 00:24:28,000

这就是我们得到这个数列的方式。如果你还不太明白,
你可以花点时间在继续此问题之前查阅一下斐波那契数列。

174
00:24:28,000 --> 00:24:34,000  

我现在会给你一点时间暂停视频,尝试自己实现这个函数。

175
00:24:34,000 --> 00:24:43,000

让我们暂停和继续。我们又回到正轨了。希望你实现起来很愉快。

176
00:24:43,000 --> 00:24:53,000

要如何实现这个功能呢?我的直觉是采用递归方式,因为斐波那契数列本身就是一种递归定义。

177
00:24:54,000 --> 00:25:04,000

我们首先知道在某些条件下你需要达到一个基本情况并停止,但我们暂时不需要知道那是什么。

178
00:25:04,000 --> 00:25:16,000 

但是我们知道在正常情况下,正确的斐波那契数等于前两个斐波那契数之和。

179
00:25:16,000 --> 00:25:28,000

所以我们不能简单地说return fib(n-1) + fib(n-2)吗?

180
00:25:29,000 --> 00:25:38,000

对我来说,这看起来非常不错。现在的问题是,我们的基本情况是什么?
我们知道斐波那契数列依赖于它前面的两个数。

181
00:25:38,000 --> 00:25:49,000

所以1依赖于这两个数。但是这两个案例,0和1,实际上并没有前两个数,对吧?

182
00:25:49,000 --> 00:25:59,000

所以0和1是我们的起点,我们必须考虑到这一点。

183
00:25:59,000 --> 00:26:10,000

那么,如果n小于或等于1,我们就直接返回n,怎么样?

184
00:26:11,000 --> 00:26:22,000

这似乎是一个相当简洁的解决方案,对吧? 我们说如果n是1,
第一个斐波那契数是1,第0个斐波那契数是0。

185
00:26:22,000 --> 00:26:31,000

所以这样处理起来很方便。这个解决方案是可行的。
恭喜你如果得到了这里,你已经有一个可工作的解决方案。

186
00:26:31,000 --> 00:26:39,000  

但我们可以做得更好,对吧?我认为我们可以得到一个更高效的程序实现。

187
00:26:39,000 --> 00:26:46,000

原因之一是,我们在递归调用时会重复大量计算,对吧?

188
00:26:46,000 --> 00:26:59,000

比如说,我们计算fib(5)时,会调用fib(4)和fib(3),对吧?

189
00:26:59,000 --> 00:27:08,000

但从fib(4)我们会调用fib(3)和fib(2),因为fib(5)等于这些。

190
00:27:08,000 --> 00:27:21,000

我的天,我甚至写不下所有的东西,对吧?就像,它不适合。
你会看到我们只计算fib(5)就计算了

191
00:27:21,000 --> 00:27:32,000

我们计算了两次fib(3),三次fib(2),无数次fib(1)和fib(0),对吧?

192
00:27:33,000 --> 00:27:39,000

所以,为什么要重复所有的这些工作呢?我们不能用不同的方式来做这个吗?

193
00:27:39,000 --> 00:27:48,000

也许我们可以从底向上构建,而不是从顶向下,这样我们就不必重复所有这些计算了。

194
00:27:48,000 --> 00:27:54,000 

我们编写程序的另一件事是,当我们像这样编写程序时,在空间上也不是很高效,

195
00:27:54,000 --> 00:28:04,000

因为第一个函数调用fib(5)依赖于它下面的两个调用,对吧?

196
00:28:04,000 --> 00:28:17,000  

所以这个调用或者函数栈框不能关闭或终止,
因为它要等待下面的两个递归调用终止后才能返回其值,对吧?

197
00:28:17,000 --> 00:28:24,000

所以所有这些函数调用都必须保持打开状态。它们都在等待下面的某个调用返回。

198
00:28:24,000 --> 00:28:36,000

你可能还记得,尾递归是61A课程涵盖的内容,这个程序不是尾递归,
因为我们必须等待函数调用返回。

199
00:28:36,000 --> 00:28:44,000

所以如果我们能避免这种情况,那么我们的程序在空间上也会更加高效,
因为我们不必保持所有这些函数调用的打开状态。

200
00:28:45,000 --> 00:28:50,000

所以,为什么我们不试着稍微改进一下,编写一个更高效的Fib版本?

201
00:28:50,000 --> 00:28:57,000

所以,我再给你一点时间暂停视频,仔细考虑我们如何做到这一点,然后再回来。

202
00:28:57,000 --> 00:29:06,000

这里我们给了你一些可以使用的额外变量。想想为什么这些变量会有帮助,
并试着将它们融入进去。

203
00:29:07,000 --> 00:29:11,000

再见。

204
00:29:11,000 --> 00:29:20,000

嗨,希望你编写Fib2的过程很愉快。如果不是,没关系,因为我们要讲解它。

205
00:29:20,000 --> 00:29:27,000

我们知道第一个Fib实现是可以的,它工作正常,但不是很高效,对吧?

206
00:29:27,000 --> 00:29:36,000

我认为很大程度上可以归咎于我们是从顶向下的。我们从fib(5)开始,
然后说,好吧,fib(4)和fib(3)是多少?

207
00:29:36,000 --> 00:29:39,000

然后从fib(4)我们说,哦,fib(3)和fib(2)是多少?

208
00:29:39,000 --> 00:29:46,000

所以我们并没有按照斐波那契数列的自然顺序来计算它,如果你明白我的意思的话,对吧?

209
00:29:46,000 --> 00:29:54,000

因为我们知道斐波那契数列,你从0和1开始,之后的每个数字都按照这个方向依次出现,对吧?

210
00:29:54,000 --> 00:30:06,000

就像,后面的所有数字都依赖于它们前面的数字。所以,从fib(5)开始,
然后询问fib(3)和fib(2)很奇怪,在计算它们之前,对吧?

211
00:30:06,000 --> 00:30:15,000  

就像我们总是在询问还没计算出的数字,所以我们必须去计算它们,
这导致了大量的重复计算,效率很低。

212
00:30:15,000 --> 00:30:21,000

而斐波那契数列的定义自然是从底部开始,然后向上构建。

213
00:30:21,000 --> 00:30:28,000

所以,为什么我们不试着这样做呢?从0和1开始,然后建立直到达到第n个数,对吧?

214
00:30:28,000 --> 00:30:38,000

所以,对我来说,这已经暗示我们将从第0个数开始,直到达到第n个数,对吧?

215
00:30:38,000 --> 00:30:47,000

我们知道如果n等于k,那意味着我们已经达到了我们正在寻找的数字,对吧?

216
00:30:47,000 --> 00:30:56,000

我们从第0个数开始,可能会递增k,直到达到第n个斐波那契数,对吧?

217
00:30:56,000 --> 00:31:01,000

这是我们的第一个小想法。

218
00:31:02,000 --> 00:31:08,000

否则,我们仍然需要继续构建这些数字,对吧?

219
00:31:08,000 --> 00:31:17,000  

我们可能会说return Fib2。我们仍然采用递归方式,因为这就是斐波那契数列的定义方式。

220
00:31:17,000 --> 00:31:23,000

让我们看看,我们仍然总是会查询同一个数字n。

221
00:31:23,000 --> 00:31:28,000

k递增,因为我们是从0开始的。

222
00:31:28,000 --> 00:31:34,000

这里的关键部分。F0和F1,我们如何将它们融入进来呢?

223
00:31:34,000 --> 00:31:42,000

我们知道第n个数总是被定义为,或者说Fib(n),对吧?

224  
00:31:42,000 --> 00:31:49,000

等于Fib(n-1)加上Fib(n-2),对吧?

225
00:31:50,000 --> 00:31:57,000

现在假设在我们最初调用斐波那契数列时,我们传入了0和1。

226
00:31:57,000 --> 00:32:02,000

所以那些是第0和第1个元素,对吧?

227
00:32:02,000 --> 00:32:09,000

它们之后的数字是什么呢?那就是F0加上F1,对吧?

228
00:32:09,000 --> 00:32:11,000

那是第二个斐波那契数。

229
00:32:12,000 --> 00:32:21,000

那么,如果这里我们传入n-1和n-2呢?

230
00:32:21,000 --> 00:32:24,000

这可能听起来有点奇怪,但让我们思考一下。

231
00:32:24,000 --> 00:32:36,000

如果我们传入F1和F0加上F1,我们会发现F1和F0加上F1是连续的斐波那契数列数字,对吧?

232
00:32:36,000 --> 00:32:38,000

F0加上F1跟在F1的后面。

233
00:32:38,000 --> 00:32:46,000

所以我们在以一种自然的方式传入这个数列,并且随着的推进,它会为我们正确构建这个数列。

234
00:32:46,000 --> 00:32:54,000

最后,我们只需要考虑递归基础情况,对吧?

235
00:32:54,000 --> 00:33:02,000

所以我们可以说,如果我们最终达到末尾,n等于k,我们要返回什么呢?

236
00:33:03,000 --> 00:33:12,000

仔细想想,我们会想返回这里传入的任何值,因为那被认为是当前数字。

237
00:33:12,000 --> 00:33:22,000

所以我们只返回F0。

238
00:33:22,000 --> 00:33:28,000

所以如果你不相信我,你可以自己试着在纸上运行这段代码。

239
00:33:29,000 --> 00:33:36,000

你会发现,我们所做的是从开始处启动,无论调用Fib2什么。

240
00:33:36,000 --> 00:33:44,000

我们需要传入我们想要的数字,比如说5。

241
00:33:44,000 --> 00:33:48,000

我们总是从第0个元素开始。

242
00:33:48,000 --> 00:33:54,000

我们传入第0和第1个斐波那契数,也就是0和1。

243
00:33:54,000 --> 00:33:58,000

所以整个东西都可以工作。你可以自己去试一试,作为一个小练习。

244
00:33:58,000 --> 00:34:06,000  

如果你不相信我的信息,你应该去试一试这个。

245
00:34:06,000 --> 00:34:09,000

你会发现程序可以工作。

246
00:34:09,000 --> 00:34:12,000

这就是本次讨论的全部内容。感谢你的参与。

247
00:34:12,000 --> 00:34:18,000

也感谢你在其他地方异步观看这个视频,谁知道你在哪里,穿着睡衣也许。

248
00:34:18,000 --> 00:34:20,000

祝你过得愉快。